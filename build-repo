#!/usr/bin/env python3

from dotenv import load_dotenv, find_dotenv
load_dotenv(find_dotenv())

import mimetypes
mimetypes.init()

import os
import sys
import subprocess
import glob
import argparse
import shutil
import json
from github3 import login
from munch import Munch
import packaging.version
from urllib.request import urlopen
from urllib.request import urlretrieve
import xml.etree.ElementTree as ET
import re
import tarfile
import configparser
import textwrap
import zipfile
from termcolor import colored
import toml

parser = argparse.ArgumentParser()
parser.add_argument('--bump', action='store_true')
parser.add_argument('--upgrade', action='store_true')
parser.add_argument('--force', action='store_true')
parser.add_argument('--dry-run', action='store_true')
parser.add_argument('--test', action='store_true')
args = parser.parse_args()

with open(os.path.join(os.path.dirname(__file__), 'config.toml')) as f:
  config = toml.load(f, _dict=Munch)

COLORS = Munch(
  repo='yellow',
  package='cyan',
  shell='magenta',
  progress='blue',
  result='green',
  error='red',
)

def run(cmd):
  print(colored(f'{cmd}', COLORS.shell))
  if os.system(cmd) != 0:
    print(colored(f'{cmd} exited with an error'), COLORS.error)
    sys.exit(1)

def rm_rf(*paths):
  for path in paths:
    if os.path.isdir(path): shutil.rmtree(path)
    if os.path.isfile(path): os.remove(path)

class Package:
  def __init__(self, package):
    package = Munch({**config.package[package.package], **package})

    # find current version
    if 'releases' in package:
      # https://www.zotero.org/download/client/manifests/release/updates-linux-i686.json
      # https://www.zotero.org/download/client/manifests/release/updates-linux-x86_64.json
      # for now, assume x86 and x64 always have same version. This needs to be fixed at some point
      response = urlopen(package.releases).read()
      if type(response) is bytes: response = response.decode("utf-8")
      releases = json.loads(response)
      self.base_version = releases[-1]['version']
    elif 'incrementals' in package:
      response = urlopen(package.incrementals).read()
      if type(response) is bytes: response = response.decode("utf-8")
      self.base_version = response.strip().split("\n")[-1]
    else:
      raise ValueError("Don't know how to check for Juris-M version")

      feed = f'https://github.com/{package.repo}/releases.atom'
      response = urlopen(feed).read()
      if type(response) is bytes: response = response.decode("utf-8")
      root = ET.fromstring(response)
      version = root.find('{http://www.w3.org/2005/Atom}entry/{http://www.w3.org/2005/Atom}id').text
      self.base_version = version.split('/')[-1]

    if args.bump or args.upgrade:
      if not 'version' in config.package[package.package]:
        self.bump = 0
        config.package[package.package].pop('bump', None)
        print(f'No version information for {package.package}, setting to {self.base_version}')
      elif packaging.version.parse(config.package[package.package].version.replace('m', '.')) < packaging.version.parse(self.base_version.replace('m', '.')):
        config.package[package.package].pop('bump', None)
        self.bump = 0
        print(f'Upgrading {package.package} to {self.base_version}')
      elif args.bump and not 'bump' in config.package[package.package]:
        config.package[package.package].bump = 1
        print(f'Bumping {package.package} to {config.package[package.package].bump}')
      elif args.bump:
        config.package[package.package].bump += 1
        print(f'Bumping {package.package} to {config.package[package.package].bump}')
      config.package[package.package].version = self.base_version

    if not 'version' in config.package[package.package]:
      print(f'No version information for {package.package}')
      sys.exit(1)
    if config.package[package.package].version != self.base_version:
      print(f'Building {config.package[package.package].version}, but {self.base_version} is available')
      sys.exit(1)

    self.version = config.package[package.package].version
    self.bump = 0
    if 'bump' in config.package[package.package]:
      self.bump = config.package[package.package].bump
      self.version += f'-{self.bump}'

    self.binary_url = package.download
    self.package = package.package
    self.name = package.name
    self.dependencies = package.dependencies
    self.global_menu = package.global_menu

    self.public = Munch.fromDict({arch: None for arch in package.archs})

    for asset in package.assets:
      m = re.match(f'{self.package}_([0-9m.]+)(?:-([0-9]+))?_([a-z0-9]+)\\.deb$', asset)
      if m:
        version = m.group(1)

        bump = m.group(2)
        bump = int(bump) if bump else 0

        arch = m.group(3)
        assert arch in package.archs, f'{arch} not in {ARCHS}'
        assert arch not in self.public or self.public[arch] is None, f'{asset} already known as {self.public[arch]}'

        self.public[arch] = Munch(base_version=version, bump=bump)

    self.needs_update = args.force
    for arch in package.archs:
      if not self.public[arch]:
        self.needs_update = True
        break
      if self.public[arch].base_version != self.base_version:
        self.needs_update = True
        break
      if self.public[arch].bump != self.bump:
        self.needs_update = True
        break

  def deb(self, arch):
    return f'{self.package}_{self.version}_{arch}.deb'

  def esr_dependencies(self):
    dependencies = []
    for dep in os.popen('apt-cache depends firefox-esr').read().split('\n'):
      dep = dep.strip()
      if not dep.startswith('Depends:'): continue
      dep = dep.split(':')[1].strip()
      if dep != 'lsb-release': # why should it need this?
        dependencies.append(dep)
    return dependencies

  def build(self, arch):
    deb = self.deb(arch)
    print(colored(f'\n## building {deb}', COLORS.package))

    rm_rf('build', 'client.tar.bz2', deb)
    os.makedirs(f'build/usr/lib/{self.package}/distribution')
    os.makedirs('build/usr/share/applications')
    os.makedirs('build/DEBIAN')
    os.makedirs('build/usr/local/bin')
    url = self.binary_url.format(arch={'amd64': 'x86_64', 'i386': 'i686'}[arch], version=self.base_version)
    print(colored(f'downloading {url}', COLORS.progress))
    urlretrieve(url, 'client.tar.bz2')

    tar = tarfile.open('client.tar.bz2')
    members = [member for member in tar.getmembers() if member.isreg()] # skip if the TarInfo is not files
    for member in tar.getmembers():
      if not member.isreg(): continue
      member.name = re.sub(r'^.+?\/', '', member.name) # strip leading directory

      if member.name in ['zotero.desktop', 'jurism.desktop', 'active-update.xml', 'precomplete', 'removed-files', 'updates', 'updates.xml']:
        continue

      tar.extract(member, f'build/usr/lib/{self.package}')
    tar.close()

    self.patch_global_menu(f'build/usr/lib/{self.package}')

    with open(f'build/usr/lib/{self.package}/distribution/policies.json', 'w') as f:
      f.write(json.dumps({ "policies": { "DisableAppUpdate": True } }))

    with open(f'build/usr/lib/{self.package}/defaults/preferences/prefs.js') as f:
      prefs_js = f.read()
    with open(f'build/usr/lib/{self.package}/defaults/preferences/prefs.js', 'w') as f:
      replace = {
        'pref("app.update.enabled", true);': 'pref("app.update.enabled", false);',
        'pref("app.update.auto", true);': 'pref("app.update.auto", false);',
      }
      for ist in list(replace.keys()):
        prefs_js = re.sub(re.escape(ist), lambda term: replace.pop(term.group()), prefs_js)
      assert len(replace) == 0, f'Not replaced: {str(replace)}'
      f.write(prefs_js)

    desktop = configparser.RawConfigParser()
    desktop.add_section('Desktop Entry')
    desktop.optionxform=str
    desktop.set('Desktop Entry', 'Name', self.name)
    if self.global_menu:
      desktop.set('Desktop Entry', 'Comment', 'Open-source reference manager (global menu support)')
    else:
      desktop.set('Desktop Entry', 'Comment', 'Open-source reference manager')
    desktop.set('Desktop Entry', 'Exec', f'/usr/lib/{self.package}/{self.package} --url %u')
    desktop.set('Desktop Entry', 'Icon', f'/usr/lib/{self.package}/chrome/icons/default/default48.png')
    desktop.set('Desktop Entry', 'Type', 'Application')
    desktop.set('Desktop Entry', 'Categories', 'Office;Education;Literature')
    desktop.set('Desktop Entry', 'StartupNotify', 'true')
    desktop.set('Desktop Entry', 'MimeType', ';'.join([
      'x-scheme-handler/zotero',

      # Research Information Systems Document
      'ris',
      'application/x-research-info-systems',
      'application/x-endnote-refer',
      'text/x-research-info-systems',
      'text/application/x-research-info-systems',
      'text/ris',

      # ISI Common Export Format Document
      'ciw',
      'isi',
      'application/x-inst-for-Scientific-info',

      # Metadata Object Description Schema Document
      'mods',
      'application/mods+xml',

      # Resource Description Framework Document
      'rdf',
      'application/rdf+xml',

      # BibTeX Document
      'bib',
      'bibtex',
      'application/x-bibtex',
      'text/x-bibtex',

      # MARC Record
      'mrc',
      'marc',
      'application/marc',

      # CSL Citation Style
      'csl',
      'vnd.citationstyles.style+xml',
    ]))

    with open(f'build/usr/share/applications/{self.package}.desktop', 'w') as f:
      desktop.write(f, space_around_delimiters=False)

    dependencies = ', '.join(sorted(list(set(self.dependencies + self.esr_dependencies()))))
    with open('build/DEBIAN/control', 'w') as f:
      print(f'Package: {self.package}', file=f)
      print(f'Architecture: {arch}', file=f)
      print(f'Depends: {dependencies}'.strip(), file=f)
      print(f'Maintainer: {config.build.maintainer}', file=f)
      print('Section: Science', file=f)
      print('Priority: optional', file=f)
      print(f'Version: {self.version}', file=f)
      print(f'Description: {self.name} is a free, easy-to-use tool to help you collect, organize, cite, and share research', file=f)

    os.symlink(f'/usr/lib/{self.package}/{self.package}', f'build/usr/local/bin/{self.package}')

    run(f'fakeroot dpkg-deb --build -Zgzip build repo/{deb}')
    run(f'dpkg-sig -k {config.build.gpgkey} --sign builder repo/{deb}')

  def patch_global_menu(self, installdir):
    if not self.global_menu: return
    print(colored('patching for global menu', COLORS.progress))

    url = urlopen('https://github.com/ripefig/Firefox-ESR-52-Global-Menu/releases/latest').geturl().replace('/tag/', '/download/') + '/libxul.so'
    urlretrieve(url, f'{installdir}/libxul.so')

    jar = os.path.join(installdir, self.package + '.jar')
    jar_gm = os.path.join(self.package + '.jar')
    with zipfile.ZipFile(jar, 'r') as zj:
      with zipfile.ZipFile(jar_gm, 'w') as zjgm:
        for item in zj.infolist():
          data = zj.read(item.filename)
          if item.filename == 'chrome/skin/default/zotero/zotero.css':
            data = data.decode('utf-8') + textwrap.dedent('''
              window[shellshowingmenubar="true"] menubar {
                display: none !important;
              }

              window[shellshowingmenubar="true"]
              toolbar[type="menubar"]:not([customizing="true"]) {
                min-height: 0 !important;
                border: 0 !important;
              }
            ''')
          zjgm.writestr(item, data)
    os.remove(jar)
    os.rename(jar_gm, jar)

# let's get it started

gh = login(token=os.getenv('GITHUB_TOKEN'))
repo = gh.repository(*config.build.repo.split('/'))

for release_name in config.release.keys():
  global_menu = release_name == 'global-menu'
  print(colored(f'\n\n# Building {release_name}', COLORS.repo))

  if args.test:
    release = repo.release_from_tag(release_name + '-test')
  else:
    release = repo.release_from_tag(release_name)

  assets = release.assets()

  packages = Munch(
    zotero = Package(Munch(
      package='zotero',
      assets=[asset.name for asset in assets],
      archs=config.release[release_name].archs,
      global_menu=global_menu
    )),
    jurism = Package(Munch(
      package='jurism',
      assets=[asset.name for asset in assets],
      archs=config.release[release_name].archs,
      global_menu=global_menu
    ))
  )
  if args.bump or args.upgrade:
    break

  if len([package for package in packages.values() if package.needs_update]) == 0:
    print(colored('nothing to do', COLORS.result))
    continue

  rm_rf('repo')
  os.mkdir('repo')

  for package in config.package.keys():
    for arch in config.release[release_name].archs:
      packages[package].build(arch)

  print(colored(f'\n## publishing {release_name}', COLORS.package))
  run(f'gpg --armor --export {config.build.gpgkey} > repo/deb.gpg.key')
  run(f'cd repo && apt-ftparchive packages . > Packages')
  run(f'bzip2 -kf repo/Packages')
  run(f'cd repo && apt-ftparchive release . > Release')
  run(f'gpg --yes -abs -u {config.build.gpgkey} -o repo/Release.gpg --digest-algo sha256 repo/Release')
  run(f'gpg --yes -abs -u {config.build.gpgkey} --clearsign -o repo/InRelease --digest-algo sha256 repo/Release')

  with open('repo/install.sh', 'w') as f:
    print(textwrap.dedent(f'''
      if [ -x "$(command -v curl)" ]; then
        curl --silent -L https://github.com/{config.build.repo}/releases/download/{release_name}/deb.gpg.key | sudo apt-key add -
      elif [ -x "$(command -v wget)" ]; then
        wget -qO- https://github.com/{config.build.repo}/releases/download/{release_name}/deb.gpg.key | sudo apt-key add -
      else
        echo "Error: need wget or curl installed." >&2
        exit 1
      fi

      cat << EOF | sudo tee /etc/apt/sources.list.d/zotero.list
      deb https://github.com/{config.build.repo}/releases/download/{release_name}/ ./
      EOF
    '''), file=f)

  if not args.dry_run:
    for asset in assets:
      asset.delete()

    for asset in sorted(glob.glob('repo/*')):
      content_type = mimetypes.guess_type(asset)[0] or 'application/octet-stream'
      print(colored(f'Uploading {asset} ({content_type})', COLORS.progress))
      with open(asset, 'rb') as f:
        release.upload_asset(
          asset=f,
          name=os.path.basename(asset),
          content_type=content_type
        )

if args.bump or args.upgrade:
  with open(os.path.join(os.path.dirname(__file__), 'config.toml'), 'w') as f:
    toml.dump(config, f)
